<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <title>LNST - Linux Network Stack Test</title>
  <meta name="generator" content="Amaya, see http://www.w3.org/Amaya/" />

  <style>
    pre {background-color: #eaeaea;}
  </style>
</head>

<body>
<h1>Linux Network Stack Test - LNST Project</h1>

<p></p>

<h2>About</h2>

<p>LNST is an automated testing framework focused on the Linux network stack testing. It supports bonding, vlan, bridging and macvlan.</p>

<h3><em>People</em></h3>
<ul>
  <li>Jiří Pírko (jpirko) – author of the project, kernel developer</li>
  <li>Jiří Župka (jzupka) – contributor,  framework infrastructure implementation,
    quality engineer</li>
  <li>Jan Tluka (jtluka) – contributor, test development, Beaker
    integration, quality engineer</li>
  <li>Radek Pazdera (rpazdera) - contributor, framework infrastructure implementation, test development, quality engineer
  <li>Ondrej Lichtner (olichtne) - contributor, framework infrastructure implementation, quality engineer
</ul>

<h3><em>Communication channels</em></h3>

<ul>
    <li>Project web page on <a>https://fedorahosted.org/lnst/</a>
    <li>We are on irc:  #lnst @ freenode (irc://irc.freenode.net#lnst)</li>
    <li>The development mailing list: <a href="https://fedorahosted.org/mailman/listinfo/lnst-developers">https://fedorahosted.org/mailman/listinfo/lnst-developers</a></li>
 </ul>


<h3><em>Goals</em></h3>
<ul>
  <li>QE: extend our current network code coverage in Tier tests</li>
  <li>Devel: create a tool/test environment to easily catch regressions in network stack during development</li>
</ul>

<h3><em>Target audience</em></h3>
<ul>
  <li>developers (to catch regressions)</li>
  <li>quality engineers (to develop new tests)</li>
</ul>

<h3><em>Topology</em></h3>

<p>In the following picture you can see an example of the network topology along with the roles and communication paths. There are 3 basic entities, </p>
<ul>
  <li>controller </li>
  <li>test machines</li>
  <li>network infrastructure (network switches)</li>
</ul>

<p></p>

<p style="text-align:left;margin-left:0;margin-right:auto;"><img
alt="Roles and communication paths" src="real-hardware-setup.png"
style="display: block; text-align: center; margin-left: auto; margin-right: auto"
width="712" height="279" /></p>

<p></p>

<p>In the picture you can see two network connections drawn in different colors. </p>

<p>The green one is the <strong>controller path</strong> and is used to setup network interfaces on machine1 and machine2 through the <strong>controller interfaces</strong> (eth3 on both test machines). The <strong>controller path</strong> is also used to do setup of the test switch and live changes on it such as vlan and bonding configuration, port disconnection, etc.</p>

<p>The red one is the <strong>test path</strong> and is used for network traffic generated in tests executed on test machines.</p>

<p></p>
<hr />

<h2>Getting the source</h2>

<p>You can access the sources at the following urls:</p>
<ul>
  <li><a
    href="http://git.fedorahosted.org/git/?p=lnst.git">http://git.fedorahosted.org/git/?p=lnst.git</a></li>
</ul>

<p>In your comand line checkout the code:</p>
<pre>$ git clone git://git.fedorahosted.org/lnst.git</pre>

<p></p>
<hr />

<h2>Source code structure</h2>

Please note, that not every file is listed.

<p></p>
<pre>[./]
    nettestctl.py          (tool to control remote machines/execute tests)
    nettestslave.py        (app that runs on remote machine and
                            accepts commands from controller (nettestctl.py))

[./Common]                 (common code for the framework)

[./recipes]                (inspiration for test setups – netconfigs, machineconfigs, recipes)

[./NetConfig]              (network configuration class implementation)

[./NetTest]                (test execution class implementation)

[./Switch]                 (network switch configuration implementation)

[./Tests]                  (implementation of network tests)

[./test_tools]             (place to keep non-python testing tools and scripts)
</pre>

<p></p>
<hr />

<h2>Setting up the test environmnent</h2>

<h3><em>Controller-Slave connection setup</em></h3>

<p>
It's mandatory to have a dedicated controller network interface on all of the test machines for both the XML-RPC connection that is used to setup network interfaces for testing and for the test execution itself. By default the xml-rpc client listens on port 9999 so if you use firewall of any sort this port needs to be open. If you want to run the tests using the "remote execution" (see chapter The Workflow - running LNST at the end of this document) you also need to have SSH daemon running on all of the test machines. It is also important to separate "controller path" and "test path" infrastructure, e.g. using two switches.</p>

<p></p>

<h3><em>Required packages</em></h3>

<p>Basically you need to have python installed. If you use RHEL5 on a machine you need to install additional package <strong>python-ctypes</strong> from EPEL repository on it.</p>
<ul>
  <li><a
    href="http://fedoraproject.org/wiki/EPEL">http://fedoraproject.org/wiki/EPEL</a></li>
  <li>rpm -ivh <a
    href="http://download.fedoraproject.org/pub/epel/5/i386/epel-release-5-4.noarch.rpm">http://download.fedoraproject.org/pub/epel/5/i386/epel-release-5-4.noarch.rpm</a></li>
  <li><a
    href="http://download.fedoraproject.org/pub/epel/5/i386/epel-release-5-4.noarch.rpm"></a>yum
    install python-ctypes</li>
</ul>

<h3><em>Optional packages</em></h3>

<p>It is recommended to install following packages. Either optional framework features rely on them or the LNST tests require them to do their work.</p>
<ul>
  <li>tcpdump</li>
  <li>nc (netcat)</li>
  <li>iperf</li>
  <li>iptables</li>
</ul>

<p></p>
<hr />

<h2>LNST Recipes</h2>

<p>The LNST recipe contains all information to do a test run.</p>

<p>It consists of:</p>
<ul>
  <li><span style="background-color:#ffc0cb">machineconfigs</span> - to define the set of machines under testing</li>
  <li><span style="background-color:#90ee90">netconfigs</span> - to define how the network interfaces should be configured</li>
  <li><span style="background-color:#add8e6">command sequences</span> - to define all test sub-tasks</li>
</ul>

<p>The following XML code is an example of the LNST recipe:</p>
<pre>&lt;nettestrecipe&gt;
    &lt;machines&gt;
         &lt;machine id="1"&gt;
             <span style="background-color:#ffc0cb">&lt;machineconfig source="recipes/team/machineconfig-test1.xml"/&gt;</span>
             <span style="background-color:#90ee90">&lt;netconfig source="recipes/team/netconfig-simple.xml"/&gt;</span>
         &lt;/machine&gt;
         &lt;machine id="2"&gt;
             <span style="background-color:#ffc0cb">&lt;machineconfig source="recipes/team/machineconfig-test2.xml"/&gt;</span>
             <span style="background-color:#90ee90">&lt;netconfig source="recipes/team/netconfig-team_ab_lw_001.xml"/&gt;</span>
         &lt;/machine&gt;
    &lt;/machines&gt;

    <span style="background-color:#add8e6">&lt;command_sequence&gt;</span>
        <span style="background-color:#add8e6">&lt;command type="exec" value="sleep 4"/&gt;</span>
        <span style="background-color:#add8e6">&lt;command type="test" machine_id="1" value="IcmpPing" timeout="30"&gt;</span>
            <span style="background-color:#add8e6">&lt;options&gt;</span>
                <span style="background-color:#add8e6">&lt;option name="addr" value="{ip(2,testip)}"/&gt;</span>
                <span style="background-color:#add8e6">&lt;option name="count" value="40"/&gt;</span>
                <span style="background-color:#add8e6">&lt;option name="interval" value="0.2"/&gt;</span>
                <span style="background-color:#add8e6">&lt;option name="limit_rate" value="95"/&gt;</span>
           <span style="background-color:#add8e6">&lt;/options&gt;</span>
        <span style="background-color:#add8e6">&lt;/command&gt;</span>
    <span style="background-color:#add8e6">&lt;/command_sequence&gt;</span>
&lt;/nettestrecipe&gt;</pre>

<p></p>

<p>Every test machine's network setup is defined by two configuration XML snippets – MachineConfig describing the machine's physical hardware (available NICs) and NetConfig describing configuration of these devices (IP addresses, bonding setup, bridging, vlans, etc.)</p>

<h3><em>MachineConfig</em></h3>

<p>The MachineConfig</p>
<ul>
  <li>describes test machine's control interface and root login information (for remote execution) - <strong>info</strong> tag</li>
  <li>describes available network interfaces of a test machine – <strong>netdevice</strong> tags</li>
</ul>

<p>Example:</p>

<p></p>
<pre>&lt;machineconfig&gt;
    &lt;info hostname="10.34.37.141" rootpass="aaa"/&gt;
    &lt;netdevices&gt;
        &lt;netdevice type="eth" network="testnet" <span style="background-color:#00ff00">phys_id="1"</span> hwaddr="00:E0:4C:14:2E:5D"/&gt;
        &lt;netdevice type="eth" network="testnet"  <span style="background-color:#00ff00">phys_id="2"</span> hwaddr="00:30:4F:7F:FD:30"/&gt;
    &lt;/netdevices&gt;
&lt;/machineconfig&gt;</pre>

<p></p>

<p>Test machine with this configuration will be accessible via IP address 10.34.37.141 using root password 'aaa' (<strong>rootpass</strong>). Two interfaces are made available for testing - one with MAC address 00:E0:4C:14:2E:5D (<strong>hwaddr</strong>) exported as physical device '1' (<strong>phys_id</strong>) and second with MAC address 00:30:4F:7F:FD:30 exported as physical device '2' in LNST framework.</p>

<p></p>

<h3><em>NetConfig</em></h3>

<p>Example:</p>
<pre>&lt;netconfig&gt;
    &lt;interface id="1" type="eth" <span style="background-color:#00ff00">phys_id="1"</span>/&gt;
    &lt;interface id="2" type="eth" <span style="background-color:#00ff00">phys_id="2"</span>/&gt;
    &lt;interface id="testifc1" <span style="background-color:#add8e6">type="bond"</span>&gt;
        &lt;options&gt;
            &lt;option name="mode" value="1"/&gt;
            &lt;option name="miimon" value="100"/&gt;
            &lt;option name="primary" value="2"/&gt;
        &lt;/options&gt;
        &lt;slaves&gt;
            &lt;slave id="1"/&gt;
            &lt;slave id="2"/&gt;
        &lt;/slaves&gt;
        &lt;addresses&gt;
            &lt;address value="192.168.101.1/24"/&gt;
        &lt;/addresses&gt;
    &lt;/interface&gt;
&lt;/netconfig&gt;</pre>

<p></p>

<p>This configuration snippet uses two physical devices
(<strong>phys_id</strong>="1" and <strong>phys_id</strong>="2") defined in the previous MachineConfig. It also defines third network device (<strong>netdevice id="3"</strong>) as <strong>bond</strong> device and adds the two physical device as its <strong>slaves</strong>. Further options are defined in <strong>options</strong> element and IP address of the bond interface is defined in <strong>addresses</strong> element.</p>

<p>Please note that you can use strings instead of just numbers for interface identification. This is very helpful when you're referring these interfaces in your command sequences. More on this in following chapter.</p>
<p></p>

<h3><em>Mapping of physical interfaces inside LNST recipes</em></h3>

<p></p>

<p><img alt="machineconfig-netconfig-mapping"
src="machineconfig-netconfig-mapping.png" width="793" height="318" /></p>

<p></p>
<h4><strong></strong></h4>

<h3><em>Command sequences</em></h3>

<p>Command sequence in a LNST recipe is a list of commands that is executed on test machines or controller. </p>

<h4><em>Commands</em></h4>

<p>Commands can be of type:</p>
<ul>
  <li><strong>type="exec"</strong> or</li>
  <li><strong>type="test"</strong>(can be run on test machines only)</li>
  <li><strong>type="intr"</strong> to interrupt (SIG_INT) commands running in background</li>
  <li><strong>type="kill"</strong> to kill (SIG_KILL) commands running in background</li>
  <li><strong>type="wait"</strong> to wait for completion of a command running in background</li>
</ul>

<p>The <strong>exec</strong> command is anything that you can enter on a
command line. E.g. </p>
<ul>
  <li>yum install tcpdump</li>
  <li>echo 1 &gt; /proc/net/ipv4/ip_forwarding</li>
</ul>

<p></p>

<p>The <strong>test</strong> command is an implemented test. The code of the test in the example below is present in Tests/Test<strong>IcmpPing</strong>.py. You can pass variables to a test using the <strong>option</strong> tag. The option value can be obtained using <strong>get_opt(),get_mopt()</strong> methods. For further details see section <strong>Writing tests</strong> or look at code examples under <strong>Tests</strong> directory.</p>

<p></p>

<p>Example of a command sequence:</p>
<pre>&lt;command_sequence&gt;
  &lt;command type="exec" value="sleep 4"/&gt;
  &lt;command type="test" machine_id="1" value="IcmpPing" timeout="30"&gt;
    &lt;options&gt;
      &lt;option name="addr" value="<span style="background-color:#ffc0cb">{$recipe['machines'][2]['netconfig'][1]['addresses'][0]}</span>" /&gt;
      &lt;option name="count" value="40"/&gt;
      &lt;option name="interval" value="0.2"/&gt;
      &lt;option name="limit_rate" value="95"/&gt;
    &lt;/options&gt;
  &lt;/command&gt;
&lt;/command_sequence&gt;</pre>

<p></p>

<p>There are two commands in this example. </p>

<p>First one would execute command sleep on the controller machine because attribute <strong>machine_id</strong> is not supplied (default behavior). The <strong>machine_id</strong> attribute defines on which of the test machines command should run. It's value matches one of the machine ids defined in <strong>&lt;machine&gt;</strong> tag in LNST recipe.</p>

<p>The second command would start <strong>IcmpPing</strong> test from the LNST test library on the test machine with <strong>id=1</strong>.</p>

<p>You can also access the configuration of machines and their interfaces from the command sequence through a special alias <span style="background-color:#ffc0cb"><strong>{$recipe}</strong></span>. In the previous example, addr option of IcmpPing test will be set to <em>first</em> assigned address from netconfig of <em>first</em> device on <em>second</em> machine.
</p>

<h4><em>Running commands in background</em></h4>

<p>Every command can be run in background. To put a command in background add the <strong>bg_id</strong> attribute to the command tag and set it's value to unique identifier, e.g. a number or a string like "iperf_server_in_bg". This identifier is later used to interrupt (<strong>intr</strong> or <strong>kill</strong>) the command or wait for it's completion(<strong>wait</strong>). 
Look at following example:

<pre>&lt;command_sequence&gt;
  &lt;command type="test" machine_id="server" value="Iperf" <span style="background-color:#ffc0cb">bg_id="iperf_server_in_bg</span>"&gt;
    &lt;options&gt;
      &lt;option name="bind" value="{ip(server,testifc1)}" /&gt;
      &lt;option name="role" value="server"/&gt;
    &lt;/options&gt;
  &lt;/command&gt;
  &lt;command type="exec" value="sleep 3"/&gt;
  &lt;command type="test" machine_id="client" value="Iperf"&gt;
    &lt;options&gt;
      &lt;option name="iperf_server" value="{ip(server,testifc1)}" /&gt;
      &lt;option name="role" value="client"/&gt;
      &lt;option name="duration" value="10"/&gt;
    &lt;/options&gt;
  &lt;/command&gt;
  &lt;command <span style="background-color:#ffc0cb">type="intr"</span> machine_id="server" <span style="background-color:#ffc0cb">value="iperf_server_in_bg"</span>/&gt;
&lt;/command_sequence&gt;</pre>



<h3><em>System Configuration</em></h3>
<p>
LNST provides a native way of changing system configuration of the slave machines from within the recipe. This can be achieved by <strong>system_config</strong> command. There are two versions of <strong>system_config</strong> command:
</p>
<h4>Inline version</h4>
<pre>
    &lt;command <span style="background-color:#add8e6">type="system_config"</span> option="/proc/sys/net/ipv4/igmp_max_memberships" value="50" machine_id="2" persistent="true" /&gt;
</pre>

<h4>Multiline version</h4>
<pre>
    &lt;command <span style="background-color:#add8e6">type="system_config"</span> machine_id="1"&gt;
        &lt;options&gt;
            &lt;option name="/proc/sys/net/ipv4/igmp_max_memberships" value="10" /&gt;
            &lt;option name="/proc/sys/net/ipv4/igmp_max_mfs" value="5" /&gt;
        &lt;/options&gt;
    &lt;/commang&gt;
</pre>

<p>
    In the multiline version you can set a several options at once.
</p>
<p>
    Unless <strong>persistent</strong> flag is set to <strong>true</strong>, all modified options are restored to their previous values <strong>at the end of the command sequence</strong>.
    The following example illustrates how this works:
<pre>
    &lt;command_sequence&gt;
        &lt;command type="system_config" machine_id="1" <span style="background-color:#ffc0cb">persistent="true"</span>&gt;
            &lt;options&gt;
                &lt;option name="/proc/sys/net/ipv4/igmp_max_memberships" value="10" /&gt;
                &lt;option name="/proc/sys/net/ipv4/igmp_max_mfs" value="5" /&gt;
            &lt;/options&gt;
        &lt;/commang&gt;
    &lt;/command_sequence&gt;
    &lt;command_sequence&gt;
        &lt;command type="system_config" option="/proc/sys/net/ipv4/igmp_max_memberships" value="50" /&gt;

        execute some test here ...
    &lt;/command_sequence&gt; <span style="background-color:#90ee90">&lt;!-- At this point, igmp_max_memberships is set back to 10 --&gt;</span>
    &lt;command_sequence&gt;
        &lt;command type="system_config" machine_id="1" <span style="background-color:#ffc0cb">persistent="true"</span>&gt;
            &lt;options&gt;
                &lt;option name="/proc/sys/net/ipv4/igmp_max_memberships" value="20" /&gt;
                &lt;option name="/proc/sys/net/ipv4/igmp_max_mfs" value="10" /&gt;
            &lt;/options&gt;
        &lt;/commang&gt;
    &lt;/command_sequence&gt;
</pre>
<p>
    The first command sequence serves as a global system setup phase, persistent flag is set to true, so the options <strong>will not</strong> be restored when the command sequence finishes.
</p>
<p>
    In the second command sequence, one option is modified for purposes of the next test, but it's not marked persistent, so the change will be automatically reverted when the command sequence comes to end.
</p>
<p>
    And the final command sequences issues a persistent command again, to make sure that system is left in a consistent state when recipe execution is over.
</p>

<hr />

<h2>Advanced recipe techniques</h2>
<p>
    This section introduces several features you can use when you decide to create your own recipe.
</p>

<h3><em>Defining aliases</em></h3>
<p>LNST allows you to define arbitrary <strong>aliases</strong> and use them to access certain values from the whole recipe file while the value itself is included in the file only once. Definition of an alias occurs in the <code>&lt;define&gt;</code> tag anywhere in the document:</p>
<pre>
&lt;define&gt;
    <span style="background-color:#90ee90">&lt;alias name="ip_addr" value="192.168.0.1" /&gt;</span>
    <span style="background-color:#add8e6">&lt;alias name="mask" value="24" /&gt;</span>
&lt;/define&gt;
</pre>

<p>Defined alias can be referenced from any element's attribute or text.
For instance:</p>
<pre>
&lt;netdevice id="2" type="eth"&gt;
    &lt;addresses&gt;
        &lt;address value="<span style="background-color:#90ee90">{$ip_addr}</span>/<span style="background-color:#add8e6">{$mask}</span>"/&gt;
    &lt;/addresses&gt;
&lt;/netdevice&gt;
</pre>

<h3><em>Template functions</em></h3>
<p>
    Template functions are conceptually quite similar to aliases, but instead of a assigned value, they represent an action that will be executed when the recipe is parsed. They can be used the same way as aliases - inside of curly braces. Currently, there are three template functions available in LNST:
</p>
<ul>
    <li><strong>ip</strong>(<em>machine_id</em>, <em>interface_id</em><em>[, address_id]</em>)
        <p>
            Returns IP address for a specific machine and interface.
            Third argument is optional and can be used when there are
            multiple IP addresses associated with a single interface.
        </p>
    </li>
    <li><strong>hwaddr</strong>(<em>machine_id</em>, <em>interface_id</em>)
        <p>
            Returns hardware address of specified interface.
        </p>
    </li>
    <li><strong>devname</strong>(<em>machine_id</em>, <em>interface_id</em>)
        <p>
            Returns device name of specified interface.
        </p>
    </li>
</ul>
<p>
    All three above mentioned functions can be used for retrieving information from machine configs, therefore calling them is only valid within a command sequence. See the following example on how this templates can be used:
</p>
<pre>
    &lt;command type="system_config" option="/proc/sys/net/ipv4/conf/<span style="background-color:#ffc0cb">{devname(1,1)}</span>/forwarding" value="1" machine_id="1" /&gt;
    &lt;command type="test" value="Multicast" machine_id="1" timeout="30"&gt;
        &lt;options&gt;
            &lt;option name="setup" value="max_groups" /&gt;
            &lt;option name="interface" value="<span style="background-color:#ffc0cb">{ip(1,1)}</span>" /&gt;
            &lt;option name="condition" value="max_groups &gt; 0" /&gt;
        &lt;/options&gt;
    &lt;/command&gt;
</pre>
<p>
    Aliases can be passed to functions as parameters, but the preprocessor does not support nesting (e.g. function cannot have another function passed as an argument).
</p>

<h3><em>Splitting recipes into multiple files</em></h3>
<p>
LNST also offers a possibility of splitting the recipe into several files. It's very helpful if you want to re-use the code in different recipes. This can be achieved by supplying <strong>source</strong> argument to an arbitrary tag. The contents of that tag then will be loaded from the file specified in the attribute's value. For instance, the following machine configuration will be loaded from file <em>peanut.xml</em>:
</p>
<pre>
&lt;machine <span style="background-color:#90ee90">source="machine_configs/peanut.xml"</span> /&gt;
</pre>
Example (<em>peanut.xml</em>):
<pre>
&lt;machine id="1"&gt;
    &lt;machineconfig <span style="background-color:#add8e6">source="example_recipes/machine_configs/config-f14peanut.xml"</span> /&gt;
    &lt;netconfig <span style="background-color:#add8e6">source="example_recipes/net_configs/netconfig1.xml"</span> /&gt;
&lt;/machine&gt;
</pre>
<p>Note that parts of the included machine config are again external.</p>

<p></p>
<hr />

<h2>Writing a test for LNST</h2>

<p>In this chapter I'm going to guide you through the process of writing a test for the LNST framework.</p>

<h3><em>Basic test</em></h3>
<h4><em>Tests code location</em></h4>

<p>All tests are stored within <b>Tests</b> directory in git repo.</p>

<p>For the purpose of this document let's assume that you're going to implement test with name <b>MyNetworkTest</b>. LNST requires that you name the python class with the prefix <b>Test</b>, therefore the class will be called <b>TestMyNetworkTest</b> and the file <b>TestMyNetworkTest.py</b>. This prefix should be omitted when you're referring it from the recipe xml.</p>

<p>So, let's start with implementation. Change to the directory <b>Tests</b> and create file <b>TestMyNetworkTest.py</b> and open it with your favorite editor.</p>

<p>Every class implementing an LNST test inherits from <code>TestGeneric</code> class from <code>TestsCommon</code> module:</p>

<pre><code>from Common.TestsCommon import TestGeneric

class TestMyNetworkTest(TestGeneric):
    ...
</code></pre>

<p>The only method you need to implement is the <code>run()</code> method and this is the code that will be executed whenever the test is referenced from the recipe.</p>

<h4><em>Passing the parameters to the test</em></h4>

<p><code>TestGeneric</code> class provides set of methods to get the parameters and their values specified in the recipe.</p>

<ul>
 <li><code>get_opt()</code></li>
 <li><code>get_mopt()</code></li>
 <li><code>get_multi_opt()</code></li>
 <li><code>get_multi_mopt()</code></li>
</ul>

<p>The <code>get_opt()</code> and <code>get_multi_opt()</code> are used to get <u>optional</u> parameters. To make a parameter <u>mandatory</u> use their <b>mopt</b> variants, <code>get_mopt()</code> and <code>get_multi_mopt()</code>.</p>

<p>For example, let's assume that your test requires a parameter containing an IP address to connect to. It's name is <b>remote_ip</b>. Additionally you want to let user to specify optional parameter saying how many messages the test should send. Let's name it <b>message_count</b>.</p>

<pre><code>class TestMyNetworkTest(TestGeneric):

    def do_some_stuff_with_parameters(self, remote_ip, count):
        s = connect(remote_ip)
        for n in range(count):
            s.send_message("data%s" % n)
        s.close()

    def run(self):
        rip = self.get_mopt("remote_ip")
        mc = self.get_opt("message_count", default=10)

        do_some_stuff_with_parameters(rip, mc)
</code></pre>

<p>And following is an example how to run your test from the recipe.</p>

<pre><code>&lt;command type="test" name="MyNetworkTest"&gt;
  &lt;options&gt;
    &lt;option name="remote_ip" value="192.168.100.10" /&gt;
    &lt;option name="message_count" value="50" /&gt;
  &lt;/options&gt;
&lt;/command&gt;
</code></pre>

<p>The <b>multi</b> variants let you specify multi-value parameters. Let's consider following example. You'd like to specify multiple remote targets for your test. Without the multi opt variant you would have to run the test multiple times from the recipe in the background. Using it you can write following command:</p>

<pre><code>&lt;command type="test" value="MyNetworkTest"&gt;
  &lt;options&gt;
    &lt;option name="remote_target" value="192.168.100.10" /&gt;
    &lt;option name="remote_target" value="192.168.100.20" /&gt;
    &lt;option name="remote_target" value="192.168.100.30" /&gt;
  &lt;/options&gt;
&lt;/command&gt;
</code></pre>

<p>And you can use following code to use all of the values:</p>

<pre><code>class TestMyNetworkTest(TestGeneric):

    def do_some_stuff_with_target(self)
        s = connect(t)
        s.send_message("hello")
        s.close()

    def run(self):
        targets = self.get_multi_opt("remote_target)
        for t in targets:
            self.do_some_stuff_with_target(t)
</code></pre>

<p>Method <code>get_multi_mopt()</code> is the same but at least one value has to be specified.</p>

<h4><em>Reporting test result</em></h4>

<p>For what reason do we have tests if they don't tell us their result?</p>

<p>The <code>TestGeneric</code> class provides two methods related to reporting the test results.</p>

<ul>
  <li><code>set_fail([message])</code></li>
  <li><code>set_pass([message])</code></li>
</ul>

<p>If you don't call any of these methods from your test the result will be always success (pass).
    Both methods take optional parameter <code>message</code> that can be used to report the result in more detail, e.g. what was the transfer rate, how many connections have been established, etc.</p>

<p>So let's enhance our example above a bit.</p>

<pre><code>class TestMyNetworkTest(TestGeneric):

    def do_some_stuff_with_target(self)
        s = connect(t)
        if not s:
            return False
        s.send_message("hello")
        s.close()

    def run(self):
        targets = self.get_multi_opt("remote_target)
        for t in targets:
            rc = self.do_some_stuff_with_target(t)
            if not rc:
                self.set_fail("Could not connect to target %s" % t)

        # if we're not reporting anything interesting, you can omit the 
        # following line
        self.set_pass()

</code></pre>

<h3><em>Advanced topics</em></h3>

<h4><em>Handling interrupts</em></h4>

<p>There are two approaches how to do this depending on the desired behaviour.</p>

<h5><em>Using the LNST facilities</em></h5>

<p>This approach is used if you need to block the execution of test. The <code>TestGeneric</code> class provides following two methods to support interrupt handling:</p>

<ul>
  <li><code>set_handle_intr()</code></li>
  <li><code>wait_on_interrupt()</code></li>
</ul>

<p>If <code>set_handle_intr()</code> method is called from the test code it simply tells the framework that the test is interested in delivering the interrupt signal. The test then can be suspended until the delivery of this signal using the <code>wait_on_interrupt()</code> method.</p>

<p>So, let's assume following command sequence:</p>

<pre><code>
&lt;command type="test" value="IntrExample" bg_id="1" /&gt; &lt;!-- (1) --&gt;
&lt;command type="exec" value="sleep 30" /&gt;              &lt;!-- (2) --&gt;
&lt;command type="intr" bg_id="1" /&gt;                     &lt;!-- (3) --&gt;
&lt;command type="wait" bg_id="1" /&gt;                     &lt;!-- (4) --&gt;
</pre></code>

<p>We're telling the framework that we want to run <b>IntrExample</b> test in the background (1), then wait for 30 seconds (2) and finally interrupt the test (3) and wait for it's exit (4).</p>

<p>The python code would look like following:</p>

<pre><code>TestIntrExample(TestGeneric):
    def run():
        self.set_handle_intr()

        ...
        # parse options
        ...
        # spawn workers or whatever that runs in background
        ...
        self.wait_on_interrupt() 
        # we're blocked until type="intr" command is executed
</code></pre>

<h5><em>Self-managed interrupt handling</em></h5>

<p>If you plan to use more complex interrupt signal handling you have to code it directly into your test code. As an example you can look at the code in <b>Tests/TestPacketAssert.py</b> or <b>Tests/TCPConnect.py</b> and <b>TCPListen.py</b></p>

<p>Basically you need to register a method for the interrupt signal. The following code should do it:</p>

<pre><code>TestIntrExample2(TestGeneric):
    def _interrupt_handler(self):
        self.do_whatever_needs_to_be_done_upon_signal_delivery()

    def run(self):
        signal.signal(signal.SIGINT, self._interrupt_handler)
</code></pre>

<p></p>
<hr />

<h2>Running in virtual environment</h2>

<p></p>
<ul>
  <li>good for developing tests</li>
  <li>easily reboot a panicked machine (virsh destroy &lt;domain&gt;; virsh
    start &lt;domain&gt;</li>
</ul>

<p>Following is an example of libvirt xmls (reduced to network snippets only). MAC addresses marked with green color should be specified in the relevant machine configs. Don't forget to add dedicated control network interface that has to stay up during the whole testing. The configuration below expects that virt guests are accessible via host's network interface therefore they're set up as <strong>type='bridge'</strong>.</p>
<pre>&lt;domain type='kvm'&gt;
    &lt;name&gt;rhel5.6-snap1&lt;/name&gt;
    ...
    &lt;devices&gt;
        ...
        &lt;interface type='bridge'&gt; &lt;!-- dedicated control interface (therefore bridged) --&gt;
            &lt;mac address='52:54:00:cc:f1:88'/&gt;
            &lt;source bridge='br0'/&gt;
            &lt;model type='virtio'/&gt;
            &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&gt;
        &lt;/interface&gt;
        &lt;interface type='network'&gt;
            &lt;mac address='<span style="background-color:#ffffff"></span><span style="background-color:#00ff00">52:54:00:3d:3e:9b</span>'/&gt;
            &lt;source network='default'/&gt;
            &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x0'/&gt;
        &lt;/interface&gt;
        &lt;interface type='network'&gt;
            &lt;mac address='<span style="background-color:#00ff00">52:54:00:44:1a:fb</span>'/&gt;
            &lt;source network='default'/&gt;
            &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x08' function='0x0'/&gt;
        &lt;/interface&gt;
        ...
    &lt;/devices&gt;
&lt;/domain&gt;


&lt;domain type='kvm'&gt;
    &lt;name&gt;rhel6ga&lt;/name&gt;
    ...
    &lt;devices&gt;
        ...
        &lt;interface type='bridge'&gt;
            &lt;mac address='52:54:00:9f:be:73'/&gt;
            &lt;source bridge='br0'/&gt;
            &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x0'/&gt;
        &lt;/interface&gt;
        &lt;interface type='network'&gt;
            &lt;mac address='<span style="background-color:#00ff00">52:54:00:2f:cc:e1</span>'/&gt;
            &lt;source network='default'/&gt;
            &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&gt;
        &lt;/interface&gt;
        &lt;interface type='network'&gt;
            &lt;mac address='<span style="background-color:#00ff00">52:54:00:dd:44:f0</span>'/&gt;
            &lt;source network='default'/&gt;
            &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x08' function='0x0'/&gt;
        &lt;/interface&gt;
        ...
    &lt;/devices&gt;
&lt;/domain&gt;</pre>
<hr />

<h2>The workflow - running LNST</h2>

<h3><em>Running LNST using remote execution</em></h3>

<p>On the controller machine run following command:</p>
<pre>&gt; ./nettestctl.py <span style="color:#ff0000">-e</span> -c my_recipe.xml run</pre>

<p>The <strong>-e</strong> option of the nettestctl.py command tells the controller to make SSH connections to all machines specified in the xml file my_recipe.xml copy the LNST code to the machines and start nettestslave.py processes on these machines. The nettestslave.py processes will start listening for XMLRPC connections through which the network interfaces will get configured. The <strong>-c</strong> option tells the controller to cleanup the test machines before any network configuration, that means removal of relevant kernel module (bonding, bridge, 8021q, etc.).</p>

<h3><em>Running LNST without remote execution</em></h3>

<p>In this case you have to start nettestslave.py processes first on all machines that are defined in recipe by yourself. Let's assume there are 2 machines participating in the test.</p>

<p>On both of these machines you have to run following command:</p>
<pre>$ ./nettestslave.py [-d]</pre>

<p>If anything goes wrong it is a good practice to pass the debug option <strong>-d</strong> because you will get information about established xmlrpc connection from the controller and also information about getting the network test interfaces ready and possible problems during the setup.</p>

<p>After a successful startup you should get following line on the output:</p>
<pre>$ ./nettestslave.py
03/05 12:32:20|       (127.0.0.1)   nettestslave:0063| INFO: Started</pre>

<p>After that you need to start nettestctl.py on the controller to run the test
in a recipe:</p>
<pre>$ ./nettestctl.py -c my_recipe.xml run</pre>

<h3><em>Using LNST to configure interfaces only</em></h3>

<p>You can also use LNST to do just the network configuration of the test machines. None of the tests inside your recipe file will get executed.</p>

<p>To do this pass <strong>config_only</strong> instead of 'run' argument to nettestctl.py script.</p>
<pre>$ ./nettestctl.py my_recipe.xml <span style="color:#ff0000"><span style="background-color:#ffffff">config_only</span></span></pre>

<p></p>
</body>
</html>
